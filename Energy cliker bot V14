from keep_alive import keep_alive
keep_alive()
import sqlite3
import logging
import os
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
    MessageHandler,
    filters,
    PicklePersistence,
    ConversationHandler
)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TOKEN = "7646768810:AAE2cjZHftbI8Xd8znr9-LdgY0K41BSlIvo"
ADMIN_ID = 7807869147
DATABASE = "bot_data.db"
PERSIST_FILE = "bot_persist.pickle"
CHANNEL_LINK = "https://t.me/EnergyClickerb"
CHANNEL_ID = "@EnergyClickerb"
REFERRAL_BONUS = 5000

# –ü—Ä–æ–º–æ–∫–æ–¥—ã {–∫–æ–¥: {"—Ç–∏–ø": "‚ö°/üíé", "–∑–Ω–∞—á–µ–Ω–∏–µ": int}}
PROMO_CODES = {}

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler
(
    AWAIT_PROMO, AWAIT_PROMO_TEXT, AWAIT_REWARD_TYPE, AWAIT_REWARD_VALUE, AWAIT_PROMO_DELETE,
    AWAIT_CHANNEL_ACTION, AWAIT_CHANNEL_ADD, AWAIT_CHANNEL_DELETE, AWAIT_CHANNEL_MESSAGE
) = range(9)

# 30 —É—Ä–æ–≤–Ω–µ–π —Å–∏–ª—ã –∫–ª–∏–∫–∞
CLICK_POWER_LEVELS = {
    1: {"power": 1, "cost": 0},
    2: {"power": 2, "cost": 100},
    3: {"power": 5, "cost": 300},
    4: {"power": 10, "cost": 700},
    5: {"power": 20, "cost": 1500},
    6: {"power": 50, "cost": 4000},
    7: {"power": 100, "cost": 10000},
    8: {"power": 200, "cost": 25000},
    9: {"power": 500, "cost": 70000},
    10: {"power": 1000, "cost": 150000},
    11: {"power": 2000, "cost": 300000},
    12: {"power": 5000, "cost": 800000},
    13: {"power": 10000, "cost": 1500000},
    14: {"power": 20000, "cost": 3000000},
    15: {"power": 50000, "cost": 8000000},
    16: {"power": 100000, "cost": 15000000},
    17: {"power": 200000, "cost": 30000000},
    18: {"power": 500000, "cost": 80000000},
    19: {"power": 1000000, "cost": 150000000},
    20: {"power": 2000000, "cost": 300000000},
    21: {"power": 5000000, "cost": 800000000},
    22: {"power": 10000000, "cost": 1500000000},
    23: {"power": 20000000, "cost": 3000000000},
    24: {"power": 50000000, "cost": 8000000000},
    25: {"power": 100000000, "cost": 15000000000},
    26: {"power": 200000000, "cost": 30000000000},
    27: {"power": 500000000, "cost": 80000000000},
    28: {"power": 1000000000, "cost": 150000000000},
    29: {"power": 2000000000, "cost": 300000000000},
    30: {"power": 5000000000, "cost": 1000000000000}
}

# 10 —É—Ä–æ–≤–Ω–µ–π –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä–∞
AUTO_CLICKER_LEVELS = {
    0: {"power": 0, "cost": 0},
    1: {"power": 5, "cost": 1000},
    2: {"power": 15, "cost": 3000},
    3: {"power": 30, "cost": 7000},
    4: {"power": 50, "cost": 15000},
    5: {"power": 100, "cost": 30000},
    6: {"power": 200, "cost": 70000},
    7: {"power": 500, "cost": 150000},
    8: {"power": 1000, "cost": 300000},
    9: {"power": 2000, "cost": 700000},
    10: {"power": 5000, "cost": 1500000}
}

# –ú–∞–≥–∞–∑–∏–Ω —ç–Ω–µ—Ä–≥–∏–∏
ENERGY_SHOP = {
    "1": {"name": "‚ö° –ú–∞–ª—ã–π –±—É—Å—Ç", "energy": 1000, "cost": 50},
    "2": {"name": "‚ö° –°—Ä–µ–¥–Ω–∏–π –±—É—Å—Ç", "energy": 5000, "cost": 200},
    "3": {"name": "‚ö° –ë–æ–ª—å—à–æ–π –±—É—Å—Ç", "energy": 20000, "cost": 700}
}

# –ú–∞–≥–∞–∑–∏–Ω –∞–ª–º–∞–∑–æ–≤
GEMS_SHOP = {
    "1": {"name": "üíé –ú–∞–ª—ã–π –Ω–∞–±–æ—Ä", "gems": 50, "cost": 1000},
    "2": {"name": "üíé –°—Ä–µ–¥–Ω–∏–π –Ω–∞–±–æ—Ä", "gems": 250, "cost": 4000},
    "3": {"name": "üíé –ë–æ–ª—å—à–æ–π –Ω–∞–±–æ—Ä", "gems": 1000, "cost": 15000}
}

# –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è (30 –∑–∞–¥–∞–Ω–∏–π)
DAILY_TASKS = [
    {"description": "–°–¥–µ–ª–∞–π—Ç–µ 50 –∫–ª–∏–∫–æ–≤", "type": "clicks", "target": 50, "reward": {"type": "‚ö°", "value": 1000}},
    {"description": "–°–æ–±–µ—Ä–∏—Ç–µ 5000 —ç–Ω–µ—Ä–≥–∏–∏", "type": "energy_collect", "target": 5000, "reward": {"type": "üíé", "value": 10}},
    {"description": "–£–ª—É—á—à–∏—Ç–µ —Å–∏–ª—É –∫–ª–∏–∫–∞ 1 —Ä–∞–∑", "type": "upgrade_click", "target": 1, "reward": {"type": "‚ö°", "value": 2000}},
    {"description": "–£–ª—É—á—à–∏—Ç–µ –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä 1 —Ä–∞–∑", "type": "upgrade_auto", "target": 1, "reward": {"type": "üíé", "value": 20}},
    {"description": "–ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ 1 –¥—Ä—É–≥–∞", "type": "referral", "target": 1, "reward": {"type": "‚ö°", "value": 3000}},
    {"description": "–°–¥–µ–ª–∞–π—Ç–µ 100 –∫–ª–∏–∫–æ–≤", "type": "clicks", "target": 100, "reward": {"type": "‚ö°", "value": 5000}},
    {"description": "–°–æ–±–µ—Ä–∏—Ç–µ 10000 —ç–Ω–µ—Ä–≥–∏–∏", "type": "energy_collect", "target": 10000, "reward": {"type": "üíé", "value": 30}},
    {"description": "–ö—É–ø–∏—Ç–µ 1 —Ç–æ–≤–∞—Ä –≤ –º–∞–≥–∞–∑–∏–Ω–µ", "type": "shop_purchase", "target": 1, "reward": {"type": "‚ö°", "value": 4000}},
    {"description": "–î–æ—Å—Ç–∏–≥–Ω–∏—Ç–µ 5 —É—Ä–æ–≤–Ω—è —Å–∏–ª—ã", "type": "click_level", "target": 5, "reward": {"type": "üíé", "value": 40}},
    {"description": "–°–¥–µ–ª–∞–π—Ç–µ 200 –∫–ª–∏–∫–æ–≤", "type": "clicks", "target": 200, "reward": {"type": "‚ö°", "value": 8000}},
    {"description": "–°–æ–±–µ—Ä–∏—Ç–µ 20000 —ç–Ω–µ—Ä–≥–∏–∏", "type": "energy_collect", "target": 20000, "reward": {"type": "üíé", "value": 50}},
    {"description": "–£–ª—É—á—à–∏—Ç–µ —Å–∏–ª—É –∫–ª–∏–∫–∞ 2 —Ä–∞–∑–∞", "type": "upgrade_click", "target": 2, "reward": {"type": "‚ö°", "value": 10000}},
    {"description": "–£–ª—É—á—à–∏—Ç–µ –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä 2 —Ä–∞–∑–∞", "type": "upgrade_auto", "target": 2, "reward": {"type": "üíé", "value": 60}},
    {"description": "–ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ 2 –¥—Ä—É–∑–µ–π", "type": "referral", "target": 2, "reward": {"type": "‚ö°", "value": 12000}},
    {"description": "–°–¥–µ–ª–∞–π—Ç–µ 300 –∫–ª–∏–∫–æ–≤", "type": "clicks", "target": 300, "reward": {"type": "‚ö°", "value": 15000}},
    {"description": "–°–æ–±–µ—Ä–∏—Ç–µ 50000 —ç–Ω–µ—Ä–≥–∏–∏", "type": "energy_collect", "target": 50000, "reward": {"type": "üíé", "value": 70}},
    {"description": "–ö—É–ø–∏—Ç–µ 3 —Ç–æ–≤–∞—Ä–∞ –≤ –º–∞–≥–∞–∑–∏–Ω–µ", "type": "shop_purchase", "target": 3, "reward": {"type": "‚ö°", "value": 18000}},
    {"description": "–î–æ—Å—Ç–∏–≥–Ω–∏—Ç–µ 10 —É—Ä–æ–≤–Ω—è —Å–∏–ª—ã", "type": "click_level", "target": 10, "reward": {"type": "üíé", "value": 80}},
    {"description": "–°–¥–µ–ª–∞–π—Ç–µ 500 –∫–ª–∏–∫–æ–≤", "type": "clicks", "target": 500, "reward": {"type": "‚ö°", "value": 25000}},
    {"description": "–°–æ–±–µ—Ä–∏—Ç–µ 100000 —ç–Ω–µ—Ä–≥–∏–∏", "type": "energy_collect", "target": 100000, "reward": {"type": "üíé", "value": 90}},
    {"description": "–£–ª—É—á—à–∏—Ç–µ —Å–∏–ª—É –∫–ª–∏–∫–∞ 3 —Ä–∞–∑–∞", "type": "upgrade_click", "target": 3, "reward": {"type": "‚ö°", "value": 30000}},
    {"description": "–£–ª—É—á—à–∏—Ç–µ –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä 3 —Ä–∞–∑–∞", "type": "upgrade_auto", "target": 3, "reward": {"type": "üíé", "value": 100}},
    {"description": "–ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ 3 –¥—Ä—É–∑–µ–π", "type": "referral", "target": 3, "reward": {"type": "‚ö°", "value": 35000}},
    {"description": "–°–¥–µ–ª–∞–π—Ç–µ 1000 –∫–ª–∏–∫–æ–≤", "type": "clicks", "target": 1000, "reward": {"type": "‚ö°", "value": 50000}},
    {"description": "–°–æ–±–µ—Ä–∏—Ç–µ 200000 —ç–Ω–µ—Ä–≥–∏–∏", "type": "energy_collect", "target": 200000, "reward": {"type": "üíé", "value": 120}},
    {"description": "–ö—É–ø–∏—Ç–µ 5 —Ç–æ–≤–∞—Ä–æ–≤ –≤ –º–∞–≥–∞–∑–∏–Ω–µ", "type": "shop_purchase", "target": 5, "reward": {"type": "‚ö°", "value": 60000}},
    {"description": "–î–æ—Å—Ç–∏–≥–Ω–∏—Ç–µ 15 —É—Ä–æ–≤–Ω—è —Å–∏–ª—ã", "type": "click_level", "target": 15, "reward": {"type": "üíé", "value": 150}},
    {"description": "–°–¥–µ–ª–∞–π—Ç–µ 2000 –∫–ª–∏–∫–æ–≤", "type": "clicks", "target": 2000, "reward": {"type": "‚ö°", "value": 80000}},
    {"description": "–°–æ–±–µ—Ä–∏—Ç–µ 500000 —ç–Ω–µ—Ä–≥–∏–∏", "type": "energy_collect", "target": 500000, "reward": {"type": "üíé", "value": 200}},
    {"description": "–î–æ—Å—Ç–∏–≥–Ω–∏—Ç–µ 20 —É—Ä–æ–≤–Ω—è —Å–∏–ª—ã", "type": "click_level", "target": 20, "reward": {"type": "üíé", "value": 300}}
]

def init_db():
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    
    # –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            energy INTEGER DEFAULT 0,
            click_power INTEGER DEFAULT 1,
            total_clicks INTEGER DEFAULT 0,
            is_subscribed BOOLEAN DEFAULT FALSE,
            gems INTEGER DEFAULT 0,
            auto_level INTEGER DEFAULT 0,
            auto_power INTEGER DEFAULT 0,
            referrer_id INTEGER DEFAULT NULL,
            referrals_count INTEGER DEFAULT 0,
            daily_task_index INTEGER DEFAULT 0,
            daily_progress INTEGER DEFAULT 0,
            daily_completed BOOLEAN DEFAULT FALSE,
            last_daily_date TEXT
        )
    """)
    
    # –¢–∞–±–ª–∏—Ü–∞ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS referrals (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            referrer_id INTEGER,
            referral_id INTEGER,
            bonus_claimed BOOLEAN DEFAULT FALSE,
            timestamp TEXT
        )
    """)
    
    # –¢–∞–±–ª–∏—Ü–∞ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS promocodes (
            code TEXT PRIMARY KEY,
            reward_type TEXT,
            reward_value INTEGER
        )
    """)
    
    # –¢–∞–±–ª–∏—Ü–∞ –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS channels (
            chat_id TEXT PRIMARY KEY
        )
    """)
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    try:
        cursor.execute("INSERT OR IGNORE INTO channels (chat_id) VALUES (?)", (CHANNEL_ID,))
    except:
        pass
    
    conn.commit()
    conn.close()

def get_user(user_id):
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
    columns = [column[0] for column in cursor.description]
    user = cursor.fetchone()
    conn.close()
    return dict(zip(columns, user)) if user else None

def update_user(user_id, **kwargs):
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    
    if not get_user(user_id):
        cursor.execute("""
            INSERT INTO users (
                user_id, username, first_name, energy, click_power, 
                total_clicks, is_subscribed, gems, auto_level, auto_power,
                referrer_id, referrals_count, daily_task_index, daily_progress,
                daily_completed, last_daily_date
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            user_id,
            kwargs.get('username'),
            kwargs.get('first_name'),
            kwargs.get('energy', 0),
            kwargs.get('click_power', 1),
            kwargs.get('total_clicks', 0),
            kwargs.get('is_subscribed', False),
            kwargs.get('gems', 0),
            kwargs.get('auto_level', 0),
            kwargs.get('auto_power', 0),
            kwargs.get('referrer_id', None),
            kwargs.get('referrals_count', 0),
            kwargs.get('daily_task_index', 0),
            kwargs.get('daily_progress', 0),
            kwargs.get('daily_completed', False),
            kwargs.get('last_daily_date', None)
        ))
    else:
        valid_keys = ['username', 'first_name', 'energy', 'click_power', 'total_clicks', 
                      'is_subscribed', 'gems', 'auto_level', 'auto_power', 
                      'referrer_id', 'referrals_count', 'daily_task_index',
                      'daily_progress', 'daily_completed', 'last_daily_date']
        safe_kwargs = {k: v for k, v in kwargs.items() if k in valid_keys}
        
        if not safe_kwargs:
            conn.close()
            return
            
        set_clause = ", ".join([f"{key} = ?" for key in safe_kwargs.keys()])
        values = list(safe_kwargs.values()) + [user_id]
        cursor.execute(f"UPDATE users SET {set_clause} WHERE user_id = ?", values)
    
    conn.commit()
    conn.close()

def load_promo_codes():
    global PROMO_CODES
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM promocodes")
    PROMO_CODES = {}
    for row in cursor.fetchall():
        code, reward_type, reward_value = row
        PROMO_CODES[code] = {"—Ç–∏–ø": reward_type, "–∑–Ω–∞—á–µ–Ω–∏–µ": reward_value}
    conn.close()

# –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫–∞–Ω–∞–ª–∞–º–∏ —Ä–∞—Å—Å—ã–ª–∫–∏
def get_channels():
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    cursor.execute("SELECT chat_id FROM channels")
    channels = [row[0] for row in cursor.fetchall()]
    conn.close()
    return channels

def add_channel(chat_id):
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    cursor.execute("INSERT OR IGNORE INTO channels (chat_id) VALUES (?)", (chat_id,))
    conn.commit()
    conn.close()

def remove_channel(chat_id):
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    cursor.execute("DELETE FROM channels WHERE chat_id = ?", (chat_id,))
    conn.commit()
    conn.close()

async def check_subscription(user_id: int, context: ContextTypes.DEFAULT_TYPE) -> bool:
    try:
        member = await context.bot.get_chat_member(chat_id=CHANNEL_ID, user_id=user_id)
        return member.status in ['member', 'administrator', 'creator']
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏: {e}")
        return False

async def auto_clicker_job(context: ContextTypes.DEFAULT_TYPE):
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    cursor.execute("SELECT user_id, auto_power FROM users WHERE auto_power > 0")
    users = cursor.fetchall()
    
    update_data = [(auto_power, user_id) for user_id, auto_power in users]
    cursor.executemany("""
        UPDATE users 
        SET energy = energy + ? 
        WHERE user_id = ?
    """, update_data)
    
    conn.commit()
    conn.close()

async def show_subscription_required(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = "üì¢ –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª!"
    keyboard = [
        [InlineKeyboardButton("üì¢ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", url=CHANNEL_LINK)],
        [InlineKeyboardButton("‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è", callback_data="check_sub")]
    ]
    
    if update.callback_query:
        await update.callback_query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    else:
        await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def show_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE, user_data: dict):
    if not await check_subscription(update.effective_user.id, context):
        await show_subscription_required(update, context)
        return

    current_level = next(
        (level for level, data in CLICK_POWER_LEVELS.items() 
         if data["power"] == user_data['click_power']), 1)
    
    next_level = current_level + 1 if current_level < 30 else None
    next_cost = CLICK_POWER_LEVELS.get(next_level, {}).get("cost", "MAX")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–µ –∑–∞–¥–∞–Ω–∏–µ
    await check_daily_task(update.effective_user.id)
    
    text = (
        f"üë§ {user_data['first_name']}\n"
        f"‚ö° –≠–Ω–µ—Ä–≥–∏—è: {user_data['energy']:,}\n"
        f"üíé –ê–ª–º–∞–∑—ã: {user_data['gems']:,}\n"
        f"üí™ –£—Ä–æ–≤–µ–Ω—å: {current_level}/30\n"
        f"üî• –°–∏–ª–∞: {user_data['click_power']:,}\n"
        f"ü§ñ –ê–≤—Ç–æ–∫–ª–∏–∫–µ—Ä: {user_data['auto_power']:,}/–º–∏–Ω\n"
        f"üë• –†–µ—Ñ–µ—Ä–∞–ª—ã: {user_data['referrals_count']:,}\n"
    )
    
    if next_level:
        text += f"üîú –°–ª–µ–¥. —É—Ä–æ–≤–µ–Ω—å: {next_cost:,}‚ö°\n"
    
    keyboard = [
        [InlineKeyboardButton("üñ± –ö–ª–∏–∫–Ω—É—Ç—å", callback_data="click"),
         InlineKeyboardButton("üí™ –£–ª—É—á—à–∏—Ç—å", callback_data="upgrade")],
        [InlineKeyboardButton("ü§ñ –ê–≤—Ç–æ–∫–ª–∏–∫–µ—Ä", callback_data="autoclicker"),
         InlineKeyboardButton("üõí –ú–∞–≥–∞–∑–∏–Ω", callback_data="shop")],
        [InlineKeyboardButton("üìù –ó–∞–¥–∞–Ω–∏—è", callback_data="daily_tasks"),
         InlineKeyboardButton("üë• –†–µ—Ñ–µ—Ä–∞–ª—ã", callback_data="referrals")],
        [InlineKeyboardButton("‚öôÔ∏è –ü—Ä–æ–º–æ–∫–æ–¥", callback_data="promo"),
         InlineKeyboardButton("üèÜ –¢–æ–ø", callback_data="top")],
        [InlineKeyboardButton("‚Ñπ –ò–Ω—Ñ–æ", callback_data="info")]
    ]
    
    if update.callback_query:
        await update.callback_query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    else:
        await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    start_payload = context.args[0] if context.args else ""
    
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–∏
    if start_payload.startswith("ref_"):
        referrer_id = int(start_payload[4:])
        if referrer_id != user.id:
            conn = sqlite3.connect(DATABASE)
            cursor = conn.cursor()
            cursor.execute("""
                INSERT OR IGNORE INTO referrals (referrer_id, referral_id, timestamp)
                VALUES (?, ?, ?)
            """, (referrer_id, user.id, str(datetime.now())))
            cursor.execute("""
                UPDATE users 
                SET energy = energy + ?,
                    referrals_count = referrals_count + 1
                WHERE user_id = ?
            """, (REFERRAL_BONUS, referrer_id))
            conn.commit()
            conn.close()
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π –¥–ª—è –ø—Ä–∏–≥–ª–∞—Å–∏–≤—à–µ–≥–æ
            referrer_data = get_user(referrer_id)
            if referrer_data and not referrer_data['daily_completed']:
                task = DAILY_TASKS[referrer_data['daily_task_index']]
                if task['type'] == "referral":
                    update_user(
                        referrer_id, 
                        daily_progress=referrer_data['daily_progress'] + 1
                    )
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    update_user(
        user.id,
        username=user.username,
        first_name=user.first_name
    )
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É
    if await check_subscription(user.id, context):
        update_user(user.id, is_subscribed=True)
        await show_main_menu(update, context, get_user(user.id))
    else:
        await show_subscription_required(update, context)

async def check_subscription_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if await check_subscription(query.from_user.id, context):
        update_user(query.from_user.id, is_subscribed=True)
        await query.edit_message_text("‚úÖ –°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É!")
        await show_main_menu(update, context, get_user(query.from_user.id))
    else:
        await query.answer("‚ùå –í—ã –µ—â—ë –Ω–µ –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å!", show_alert=True)
        await show_subscription_required(update, context)

async def handle_click(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if not await check_subscription(query.from_user.id, context):
        await show_subscription_required(update, context)
        return
    
    user_data = get_user(query.from_user.id)
    new_energy = user_data['energy'] + user_data['click_power']
    total_clicks = user_data['total_clicks'] + 1
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π
    if not user_data['daily_completed']:
        task = DAILY_TASKS[user_data['daily_task_index']]
        if task['type'] == "clicks":
            update_user(
                query.from_user.id,
                energy=new_energy,
                total_clicks=total_clicks,
                daily_progress=user_data['daily_progress'] + 1
            )
        elif task['type'] == "energy_collect":
            update_user(
                query.from_user.id,
                energy=new_energy,
                total_clicks=total_clicks,
                daily_progress=user_data['daily_progress'] + user_data['click_power']
            )
        else:
            update_user(
                query.from_user.id,
                energy=new_energy,
                total_clicks=total_clicks
            )
    else:
        update_user(
            query.from_user.id,
            energy=new_energy,
            total_clicks=total_clicks
        )
    
    await query.edit_message_text(
        f"üí• +{user_data['click_power']:,}‚ö°\n"
        f"üîã –í—Å–µ–≥–æ: {new_energy:,}",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üñ± –ï—â—ë –∫–ª–∏–∫", callback_data="click")],
            [InlineKeyboardButton("üîô –ú–µ–Ω—é", callback_data="menu")]
        ])
    )

async def upgrade_click(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if not await check_subscription(query.from_user.id, context):
        await show_subscription_required(update, context)
        return
    
    user_data = get_user(query.from_user.id)
    
    current_level = next(
        (level for level, data in CLICK_POWER_LEVELS.items() 
         if data["power"] == user_data['click_power']), 1)
    
    if current_level >= 30:
        await query.answer("üéâ –ú–∞–∫—Å. —É—Ä–æ–≤–µ–Ω—å –¥–æ—Å—Ç–∏–≥–Ω—É—Ç!", show_alert=True)
        return
    
    next_level = current_level + 1
    next_data = CLICK_POWER_LEVELS[next_level]
    
    if user_data['energy'] < next_data['cost']:
        await query.answer(f"‚ùå –ù—É–∂–Ω–æ {next_data['cost']:,}‚ö°", show_alert=True)
        return
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π
    if not user_data['daily_completed']:
        task = DAILY_TASKS[user_data['daily_task_index']]
        if task['type'] == "upgrade_click":
            update_user(
                query.from_user.id,
                energy=user_data['energy'] - next_data['cost'],
                click_power=next_data['power'],
                daily_progress=user_data['daily_progress'] + 1
            )
        elif task['type'] == "click_level":
            update_user(
                query.from_user.id,
                energy=user_data['energy'] - next_data['cost'],
                click_power=next_data['power'],
                daily_progress=next_level
            )
        else:
            update_user(
                query.from_user.id,
                energy=user_data['energy'] - next_data['cost'],
                click_power=next_data['power']
            )
    else:
        update_user(
            query.from_user.id,
            energy=user_data['energy'] - next_data['cost'],
            click_power=next_data['power']
        )
    
    await query.answer(f"‚úÖ –£—Ä. {next_level}! –°–∏–ª–∞: {next_data['power']:,}‚ö°", show_alert=True)
    await show_main_menu(update, context, get_user(query.from_user.id))

async def autoclicker_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if not await check_subscription(query.from_user.id, context):
        await show_subscription_required(update, context)
        return
    
    user_data = get_user(query.from_user.id)
    
    text = f"ü§ñ –ê–≤—Ç–æ–∫–ª–∏–∫–µ—Ä (—É—Ä–æ–≤–µ–Ω—å {user_data['auto_level']}/10)\n"
    text += f"‚ö° {user_data['auto_power']} —ç–Ω–µ—Ä–≥–∏–∏/–º–∏–Ω\n\n"
    
    next_level = user_data['auto_level'] + 1 if user_data['auto_level'] < 10 else 10
    if next_level <= 10:
        next_cost = AUTO_CLICKER_LEVELS[next_level]["cost"]
        text += f"–°–ª–µ–¥. —É—Ä–æ–≤–µ–Ω—å: +{AUTO_CLICKER_LEVELS[next_level]['power']}‚ö°/–º–∏–Ω ({next_cost:,}üíé)\n"
    
    keyboard = [
        [InlineKeyboardButton(f"–£–ª—É—á—à–∏—Ç—å ({next_cost:,}üíé)", callback_data=f"upgrade_auto_{next_level}")] if next_level <= 10 else [],
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="menu")]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def upgrade_autoclicker(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if not await check_subscription(query.from_user.id, context):
        await show_subscription_required(update, context)
        return
    
    user_id = query.from_user.id
    user_data = get_user(user_id)
    
    next_level = int(query.data.split("_")[-1])
    if user_data['auto_level'] >= next_level:
        await query.answer("‚ùå –£–∂–µ —É–ª—É—á—à–µ–Ω–æ!")
        return
    
    cost = AUTO_CLICKER_LEVELS[next_level]["cost"]
    if user_data['gems'] < cost:
        await query.answer(f"‚ùå –ù—É–∂–Ω–æ {cost:,}üíé", show_alert=True)
        return
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π
    if not user_data['daily_completed']:
        task = DAILY_TASKS[user_data['daily_task_index']]
        if task['type'] == "upgrade_auto":
            update_user(
                user_id,
                auto_level=next_level,
                auto_power=AUTO_CLICKER_LEVELS[next_level]["power"],
                gems=user_data['gems'] - cost,
                daily_progress=user_data['daily_progress'] + 1
            )
        else:
            update_user(
                user_id,
                auto_level=next_level,
                auto_power=AUTO_CLICKER_LEVELS[next_level]["power"],
                gems=user_data['gems'] - cost
            )
    else:
        update_user(
            user_id,
            auto_level=next_level,
            auto_power=AUTO_CLICKER_LEVELS[next_level]["power"],
            gems=user_data['gems'] - cost
        )
    
    await query.answer(f"‚úÖ –ê–≤—Ç–æ–∫–ª–∏–∫–µ—Ä —É–ª—É—á—à–µ–Ω –¥–æ {next_level} —É—Ä–æ–≤–Ω—è!", show_alert=True)
    await autoclicker_menu(update, context)

async def shop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.callback_query:
        user_id = update.callback_query.from_user.id
    else:
        user_id = update.message.from_user.id
    
    if not await check_subscription(user_id, context):
        await show_subscription_required(update, context)
        return
    
    text = "üõí –í—ã–±–µ—Ä–∏—Ç–µ –º–∞–≥–∞–∑–∏–Ω:"
    keyboard = [
        [InlineKeyboardButton("‚ö° –≠–Ω–µ—Ä–≥–∏—è", callback_data="shop_energy"),
         InlineKeyboardButton("üíé –ê–ª–º–∞–∑—ã", callback_data="shop_gems")],
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="menu")]
    ]
    
    if update.callback_query:
        await update.callback_query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    else:
        await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def shop_energy(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if not await check_subscription(query.from_user.id, context):
        await show_subscription_required(update, context)
        return
    
    text = "‚ö° –ö—É–ø–∏—Ç—å —ç–Ω–µ—Ä–≥–∏—é:\n"
    for item_id, item in ENERGY_SHOP.items():
        text += f"\n{item['name']} - {item['energy']:,}‚ö° ({item['cost']:,}üíé)"
    
    keyboard = [
        [InlineKeyboardButton(f"–ö—É–ø–∏—Ç—å {ENERGY_SHOP['1']['name']}", callback_data="buy_energy_1")],
        [InlineKeyboardButton(f"–ö—É–ø–∏—Ç—å {ENERGY_SHOP['2']['name']}", callback_data="buy_energy_2")],
        [InlineKeyboardButton(f"–ö—É–ø–∏—Ç—å {ENERGY_SHOP['3']['name']}", callback_data="buy_energy_3")],
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="shop")]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def shop_gems(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if not await check_subscription(query.from_user.id, context):
        await show_subscription_required(update, context)
        return
    
    text = "üíé –ö—É–ø–∏—Ç—å –∞–ª–º–∞–∑—ã:\n"
    for item_id, item in GEMS_SHOP.items():
        text += f"\n{item['name']} - {item['gems']:,}üíé ({item['cost']:,}‚ö°)"
    
    keyboard = [
        [InlineKeyboardButton(f"–ö—É–ø–∏—Ç—å {GEMS_SHOP['1']['name']}", callback_data="buy_gems_1")],
        [InlineKeyboardButton(f"–ö—É–ø–∏—Ç—å {GEMS_SHOP['2']['name']}", callback_data="buy_gems_2")],
        [InlineKeyboardButton(f"–ö—É–ø–∏—Ç—å {GEMS_SHOP['3']['name']}", callback_data="buy_gems_3")],
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="shop")]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def buy_item(update: Update, context: ContextTypes.DEFAULT_TYPE, item_type: str, item_id: str):
    query = update.callback_query
    await query.answer()
    
    if not await check_subscription(query.from_user.id, context):
        await show_subscription_required(update, context)
        return
    
    user_data = get_user(query.from_user.id)
    shop = ENERGY_SHOP if item_type == "energy" else GEMS_SHOP
    item = shop[item_id]
    
    if item_type == "energy":
        if user_data['gems'] < item['cost']:
            await query.answer(f"‚ùå –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç {item['cost']:,}üíé", show_alert=True)
            return
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π
        if not user_data['daily_completed']:
            task = DAILY_TASKS[user_data['daily_task_index']]
            if task['type'] == "shop_purchase":
                update_user(
                    query.from_user.id,
                    energy=user_data['energy'] + item['energy'],
                    gems=user_data['gems'] - item['cost'],
                    daily_progress=user_data['daily_progress'] + 1
                )
            else:
                update_user(
                    query.from_user.id,
                    energy=user_data['energy'] + item['energy'],
                    gems=user_data['gems'] - item['cost']
                )
        else:
            update_user(
                query.from_user.id,
                energy=user_data['energy'] + item['energy'],
                gems=user_data['gems'] - item['cost']
            )
        await query.answer(f"‚úÖ –ö—É–ø–ª–µ–Ω–æ {item['energy']:,}‚ö°", show_alert=True)
        await shop_energy(update, context)
    else:
        if user_data['energy'] < item['cost']:
            await query.answer(f"‚ùå –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç {item['cost']:,}‚ö°", show_alert=True)
            return
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π
        if not user_data['daily_completed']:
            task = DAILY_TASKS[user_data['daily_task_index']]
            if task['type'] == "shop_purchase":
                update_user(
                    query.from_user.id,
                    gems=user_data['gems'] + item['gems'],
                    energy=user_data['energy'] - item['cost'],
                    daily_progress=user_data['daily_progress'] + 1
                )
            else:
                update_user(
                    query.from_user.id,
                    gems=user_data['gems'] + item['gems'],
                    energy=user_data['energy'] - item['cost']
                )
        else:
            update_user(
                query.from_user.id,
                gems=user_data['gems'] + item['gems'],
                energy=user_data['energy'] - item['cost']
            )
        await query.answer(f"‚úÖ –ö—É–ø–ª–µ–Ω–æ {item['gems']:,}üíé", show_alert=True)
        await shop_gems(update, context)

async def top_players(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.callback_query:
        user_id = update.callback_query.from_user.id
    else:
        user_id = update.message.from_user.id
    
    if not await check_subscription(user_id, context):
        await show_subscription_required(update, context)
        return
    
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    cursor.execute("SELECT first_name, total_clicks FROM users ORDER BY total_clicks DESC LIMIT 10")
    top = cursor.fetchall()
    conn.close()
    
    text = "üèÜ –¢–æ–ø –∏–≥—Ä–æ–∫–æ–≤:\n\n"
    text += "\n".join([f"{i+1}. {name}: {clicks:,} –∫–ª–∏–∫–æ–≤" for i, (name, clicks) in enumerate(top)])
    
    if update.callback_query:
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="menu")]])
        )
    else:
        await update.message.reply_text(text)

async def info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.callback_query:
        user_id = update.callback_query.from_user.id
    else:
        user_id = update.message.from_user.id
    
    if not await check_subscription(user_id, context):
        await show_subscription_required(update, context)
        return
    
    text = (
        "‚Ñπ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:\n\n"
        "üîπ –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/start - –ù–∞—á–∞—Ç—å –∏–≥—Ä—É\n"
        "/shop - –ú–∞–≥–∞–∑–∏–Ω—ã\n"
        "/top - –¢–æ–ø –∏–≥—Ä–æ–∫–æ–≤\n\n"
        f"üì¢ –ö–∞–Ω–∞–ª: {CHANNEL_ID}"
    )
    
    if update.callback_query:
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="menu")]])
        )
    else:
        await update.message.reply_text(text)

async def referrals_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if not await check_subscription(query.from_user.id, context):
        await show_subscription_required(update, context)
        return
    
    user_data = get_user(query.from_user.id)
    bot_username = (await context.bot.get_me()).username
    
    text = f"üë• –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞\n\n"
    text += f"üîπ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ: {user_data['referrals_count']}\n"
    text += f"üîπ –ë–æ–Ω—É—Å –∑–∞ —Ä–µ—Ñ–µ—Ä–∞–ª–∞: {REFERRAL_BONUS:,}‚ö°\n\n"
    text += f"–í–∞—à–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:\n"
    text += f"https://t.me/{bot_username}?start=ref_{query.from_user.id}\n\n"
    text += f"–ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π—Ç–µ –±–æ–Ω—É—Å—ã!"
    
    keyboard = [
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="menu")]
    ]
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def promo_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_subscription(update.effective_user.id, context):
        await show_subscription_required(update, context)
        return
    
    keyboard = [
        [InlineKeyboardButton("‚öôÔ∏è –í–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–æ–∫–æ–¥", callback_data="enter_promo")]
    ]
    if update.callback_query:
        await update.callback_query.edit_message_text(
            "üéÅ –°–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    else:
        await update.message.reply_text(
            "üéÅ –°–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

async def handle_promo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("üìù –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–æ–∫–æ–¥:")
    return AWAIT_PROMO

async def apply_promo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_input = update.message.text.strip().upper()
    load_promo_codes()
    
    if user_input in PROMO_CODES:
        reward = PROMO_CODES[user_input]
        user = get_user(update.effective_user.id)
        
        if reward["—Ç–∏–ø"] == "‚ö°":
            update_user(user_id=update.effective_user.id, energy=user['energy'] + reward["–∑–Ω–∞—á–µ–Ω–∏–µ"])
            await update.message.reply_text(f"üéâ –ü–æ–ª—É—á–µ–Ω–æ: {reward['–∑–Ω–∞—á–µ–Ω–∏–µ']}‚ö°")
        else:
            update_user(user_id=update.effective_user.id, gems=user['gems'] + reward["–∑–Ω–∞—á–µ–Ω–∏–µ"])
            await update.message.reply_text(f"üéâ –ü–æ–ª—É—á–µ–Ω–æ: {reward['–∑–Ω–∞—á–µ–Ω–∏–µ']}üíé")
    else:
        await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –ø—Ä–æ–º–æ–∫–æ–¥")
    return ConversationHandler.END

async def admin_promo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return
    
    load_promo_codes()
    keyboard = [
        [InlineKeyboardButton("‚úÖ –î–æ–±–∞–≤–∏—Ç—å", callback_data="add_promo")],
        [InlineKeyboardButton("‚ùå –£–¥–∞–ª–∏—Ç—å", callback_data="del_promo")]
    ]
    await update.message.reply_text(
        f"üîß –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞–º–∏ (–≤—Å–µ–≥–æ: {len(PROMO_CODES)})\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=InlineKeyboardMarkup(keyboard))

async def promo_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == "add_promo":
        await query.edit_message_text("üìù –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –ø—Ä–æ–º–æ–∫–æ–¥–∞ (–∞–Ω–≥–ª/—Ü–∏—Ñ—Ä—ã):")
        return AWAIT_PROMO_TEXT
    else:
        await query.edit_message_text("üóë –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–æ–∫–æ–¥ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:")
        return AWAIT_PROMO_DELETE

async def process_promo_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["promo_code"] = update.message.text.strip().upper()
    keyboard = [
        [InlineKeyboardButton("‚ö° –≠–Ω–µ—Ä–≥–∏—è", callback_data="reward_energy")],
        [InlineKeyboardButton("üíé –ê–ª–º–∞–∑—ã", callback_data="reward_gems")]
    ]
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –Ω–∞–≥—Ä–∞–¥—ã:",
        reply_markup=InlineKeyboardMarkup(keyboard))

async def process_reward_value(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    context.user_data["reward_type"] = "‚ö°" if query.data == "reward_energy" else "üíé"
    await query.edit_message_text("üí∞ –í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–≥—Ä–∞–¥—ã (—á–∏—Å–ª–æ):")
    return AWAIT_REWARD_VALUE

async def save_promo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        value = int(update.message.text)
        code = context.user_data["promo_code"]
        r_type = context.user_data["reward_type"]
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
        conn = sqlite3.connect(DATABASE)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT OR REPLACE INTO promocodes (code, reward_type, reward_value)
            VALUES (?, ?, ?)
        """, (code, r_type, value))
        conn.commit()
        conn.close()
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–µ—à
        load_promo_codes()
        
        await update.message.reply_text(f"‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ ¬´{code}¬ª –¥–æ–±–∞–≤–ª–µ–Ω!")
    except ValueError:
        await update.message.reply_text("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!")
    return ConversationHandler.END

async def delete_promo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    code = update.message.text.strip().upper()
    load_promo_codes()
    
    if code in PROMO_CODES:
        conn = sqlite3.connect(DATABASE)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM promocodes WHERE code = ?", (code,))
        conn.commit()
        conn.close()
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–µ—à
        load_promo_codes()
        
        await update.message.reply_text(f"‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ ¬´{code}¬ª —É–¥–∞–ª—ë–Ω!")
    else:
        await update.message.reply_text("‚ùå –ü—Ä–æ–º–æ–∫–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω")
    return ConversationHandler.END

async def infinity(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return
    
    if len(context.args) < 2:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:\n/infinity @user 1000\n/infinity –≤—Å–µ–º 1000")
        return
    
    try:
        amount = int(context.args[1])
        if context.args[0] == "–≤—Å–µ–º":
            conn = sqlite3.connect(DATABASE)
            cursor = conn.cursor()
            cursor.execute("UPDATE users SET energy = energy + ?", (amount,))
            conn.commit()
            conn.close()
            await update.message.reply_text(f"‚úÖ –í—Å–µ–º –≤—ã–¥–∞–Ω–æ {amount:,}‚ö°")
        else:
            username = context.args[0].lstrip('@')
            conn = sqlite3.connect(DATABASE)
            cursor = conn.cursor()
            cursor.execute("UPDATE users SET energy = energy + ? WHERE username = ?", (amount, username))
            conn.commit()
            conn.close()
            await update.message.reply_text(f"‚úÖ @{username} –ø–æ–ª—É—á–∏–ª {amount:,}‚ö°")
    except Exception as e:
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {e}")

async def infinity_v2(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return
    
    if len(context.args) < 2:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:\n/infinityV2 @user 100\n/infinityV2 –≤—Å–µ–º 1000")
        return
    
    try:
        amount = int(context.args[1])
        if context.args[0] == "–≤—Å–µ–º":
            conn = sqlite3.connect(DATABASE)
            cursor = conn.cursor()
            cursor.execute("UPDATE users SET gems = gems + ?", (amount,))
            conn.commit()
            conn.close()
            await update.message.reply_text(f"‚úÖ –í—Å–µ–º –≤—ã–¥–∞–Ω–æ {amount:,}üíé")
        else:
            username = context.args[0].lstrip('@')
            conn = sqlite3.connect(DATABASE)
            cursor = conn.cursor()
            cursor.execute("UPDATE users SET gems = gems + ? WHERE username = ?", (amount, username))
            conn.commit()
            conn.close()
            await update.message.reply_text(f"‚úÖ @{username} –ø–æ–ª—É—á–∏–ª {amount:,}üíé")
    except Exception as e:
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {e}")

async def chatbot(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return
    
    if not context.args:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:\n/chatbot [—Ç–µ–∫—Å—Ç]")
        return

    message = ' '.join(context.args)
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    cursor.execute("SELECT user_id FROM users")
    users = [row[0] for row in cursor.fetchall()]
    conn.close()
    
    success = 0
    total = len(users)
    for user_id in users:
        try:
            await context.bot.send_message(chat_id=user_id, text=message)
            success += 1
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ {user_id}: {e}")
    
    await update.message.reply_text(f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {success}/{total} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º")

async def chatbotV2_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return
    
    channels = get_channels()
    text = "üì¢ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–æ–π –≤ —á–∞—Ç—ã/–∫–∞–Ω–∞–ª—ã\n\n"
    text += f"üîπ –¢–µ–∫—É—â–∏–µ —á–∞—Ç—ã –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ ({len(channels)}):\n"
    text += "\n".join([f"‚Ä¢ {chat}" for chat in channels])
    
    keyboard = [
        [InlineKeyboardButton("‚úÖ –î–æ–±–∞–≤–∏—Ç—å —á–∞—Ç", callback_data="add_channel")],
        [InlineKeyboardButton("‚ùå –£–¥–∞–ª–∏—Ç—å —á–∞—Ç", callback_data="remove_channel")],
        [InlineKeyboardButton("‚öôÔ∏è –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ", callback_data="send_to_channels")]
    ]
    
    await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    return AWAIT_CHANNEL_ACTION

async def handle_channel_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == "add_channel":
        await query.edit_message_text("‚ûï –í–≤–µ–¥–∏—Ç–µ @username –∏–ª–∏ ID —á–∞—Ç–∞ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è:")
        return AWAIT_CHANNEL_ADD
    elif query.data == "remove_channel":
        await query.edit_message_text("‚ûñ –í–≤–µ–¥–∏—Ç–µ @username –∏–ª–∏ ID —á–∞—Ç–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:")
        return AWAIT_CHANNEL_DELETE
    elif query.data == "send_to_channels":
        await query.edit_message_text("üìù –í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏:")
        return AWAIT_CHANNEL_MESSAGE

async def add_channel_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.text.strip()
    add_channel(chat_id)
    await update.message.reply_text(f"‚úÖ –ß–∞—Ç {chat_id} –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å–ø–∏—Å–æ–∫ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏!")
    return ConversationHandler.END

async def remove_channel_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.text.strip()
    remove_channel(chat_id)
    await update.message.reply_text(f"‚úÖ –ß–∞—Ç {chat_id} —É–¥–∞–ª—ë–Ω –∏–∑ —Å–ø–∏—Å–∫–∞ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏!")
    return ConversationHandler.END

async def send_to_channels(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message.text
    channels = get_channels()
    success = 0
    total = len(channels)
    
    for chat_id in channels:
        try:
            await context.bot.send_message(chat_id=chat_id, text=message)
            success += 1
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ {chat_id}: {e}")
    
    await update.message.reply_text(f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ {success}/{total} —á–∞—Ç–æ–≤/–∫–∞–Ω–∞–ª–æ–≤!")
    return ConversationHandler.END

# –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π
async def check_daily_task(user_id):
    user = get_user(user_id)
    today = datetime.now().strftime("%Y-%m-%d")
    
    if user['last_daily_date'] != today:
        new_index = (user['daily_task_index'] + 1) % len(DAILY_TASKS)
        update_user(
            user_id,
            daily_task_index=new_index,
            daily_progress=0,
            daily_completed=False,
            last_daily_date=today
        )
        return True
    return False

async def show_daily_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    await check_daily_task(user_id)
    user_data = get_user(user_id)
    task = DAILY_TASKS[user_data['daily_task_index']]
    
    progress_text = ""
    if task['type'] == "clicks":
        progress_text = f"–ü—Ä–æ–≥—Ä–µ—Å—Å: {user_data['daily_progress']}/{task['target']} –∫–ª–∏–∫–æ–≤"
    elif task['type'] == "energy_collect":
        progress_text = f"–ü—Ä–æ–≥—Ä–µ—Å—Å: {user_data['daily_progress']}/{task['target']} —ç–Ω–µ—Ä–≥–∏–∏"
    elif task['type'] == "upgrade_click":
        progress_text = f"–ü—Ä–æ–≥—Ä–µ—Å—Å: {user_data['daily_progress']}/{task['target']} —É–ª—É—á—à–µ–Ω–∏–π"
    elif task['type'] == "upgrade_auto":
        progress_text = f"–ü—Ä–æ–≥—Ä–µ—Å—Å: {user_data['daily_progress']}/{task['target']} —É–ª—É—á—à–µ–Ω–∏–π"
    elif task['type'] == "referral":
        progress_text = f"–ü—Ä–æ–≥—Ä–µ—Å—Å: {user_data['daily_progress']}/{task['target']} –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π"
    elif task['type'] == "shop_purchase":
        progress_text = f"–ü—Ä–æ–≥—Ä–µ—Å—Å: {user_data['daily_progress']}/{task['target']} –ø–æ–∫—É–ø–æ–∫"
    elif task['type'] == "click_level":
        current_level = next((lvl for lvl, data in CLICK_POWER_LEVELS.items() 
                             if data["power"] == user_data['click_power']), 1)
        progress_text = f"–¢–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å: {current_level}/{task['target']}"
    
    text = (
        f"üìù –ï–∂–µ–¥–Ω–µ–≤–Ω–æ–µ –∑–∞–¥–∞–Ω–∏–µ\n\n"
        f"{task['description']}\n"
        f"{progress_text}\n\n"
        f"–ù–∞–≥—Ä–∞–¥–∞: {task['reward']['value']}{task['reward']['type']}"
    )
    
    keyboard = []
    if not user_data['daily_completed'] and user_data['daily_progress'] >= task['target']:
        keyboard.append([InlineKeyboardButton("üéÅ –ü–æ–ª—É—á–∏—Ç—å –Ω–∞–≥—Ä–∞–¥—É", callback_data="claim_daily")])
    
    keyboard.append([InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="menu")])
    
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def claim_daily_reward(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    user_data = get_user(user_id)
    task = DAILY_TASKS[user_data['daily_task_index']]
    
    if user_data['daily_completed']:
        await query.answer("–í—ã —É–∂–µ –ø–æ–ª—É—á–∏–ª–∏ –Ω–∞–≥—Ä–∞–¥—É –∑–∞ —ç—Ç–æ –∑–∞–¥–∞–Ω–∏–µ!", show_alert=True)
        return
    
    if user_data['daily_progress'] < task['target']:
        await query.answer("–ó–∞–¥–∞–Ω–∏–µ –µ—â–µ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ!", show_alert=True)
        return
    
    # –í—ã–¥–∞–µ–º –Ω–∞–≥—Ä–∞–¥—É
    if task['reward']['type'] == "‚ö°":
        update_user(user_id, energy=user_data['energy'] + task['reward']['value'], daily_completed=True)
    else:
        update_user(user_id, gems=user_data['gems'] + task['reward']['value'], daily_completed=True)
    
    await query.answer(f"–ü–æ–ª—É—á–µ–Ω–æ {task['reward']['value']}{task['reward']['type']}!", show_alert=True)
    await show_daily_tasks(update, context)

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    
    if data == "click":
        await handle_click(update, context)
    elif data == "upgrade":
        await upgrade_click(update, context)
    elif data == "menu":
        user_data = get_user(query.from_user.id)
        await show_main_menu(update, context, user_data)
    elif data == "autoclicker":
        await autoclicker_menu(update, context)
    elif data.startswith("upgrade_auto_"):
        await upgrade_autoclicker(update, context)
    elif data == "shop":
        await shop(update, context)
    elif data == "shop_energy":
        await shop_energy(update, context)
    elif data.startswith("buy_energy_"):
        await buy_item(update, context, "energy", data.split("_")[-1])
    elif data == "shop_gems":
        await shop_gems(update, context)
    elif data.startswith("buy_gems_"):
        await buy_item(update, context, "gems", data.split("_")[-1])
    elif data == "top":
        await top_players(update, context)
    elif data == "info":
        await info(update, context)
    elif data == "referrals":
        await referrals_menu(update, context)
    elif data == "check_sub":
        await check_subscription_handler(update, context)
    elif data == "promo":
        await promo_menu(update, context)
    elif data == "enter_promo":
        await handle_promo(update, context)
    elif data in ["add_promo", "del_promo"]:
        await promo_action(update, context)
    elif data in ["reward_energy", "reward_gems"]:
        await process_reward_value(update, context)
    elif data == "daily_tasks":
        await show_daily_tasks(update, context)
    elif data == "claim_daily":
        await claim_daily_reward(update, context)

def main():
    init_db()
    load_promo_codes()
    persistence = PicklePersistence(filepath=PERSIST_FILE)
    
    # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π JobQueue
    application = Application.builder().token(TOKEN).persistence(persistence).build()
    
    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("shop", shop))
    application.add_handler(CommandHandler("top", top_players))
    application.add_handler(CommandHandler("info", info))
    application.add_handler(CommandHandler("infinity", infinity))
    application.add_handler(CommandHandler("infinityV2", infinity_v2))
    application.add_handler(CommandHandler("code", admin_promo))
    application.add_handler(CommandHandler("chatbot", chatbot))
    
    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫
    application.add_handler(CallbackQueryHandler(button_handler))
    
    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤
    promo_conv_handler = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(handle_promo, pattern="^enter_promo$"),
            CommandHandler("code", admin_promo)
        ],
        states={
            AWAIT_PROMO: [MessageHandler(filters.TEXT & ~filters.COMMAND, apply_promo)],
            AWAIT_PROMO_TEXT: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_promo_text)],
            AWAIT_REWARD_TYPE: [CallbackQueryHandler(process_reward_value)],
            AWAIT_REWARD_VALUE: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_promo)],
            AWAIT_PROMO_DELETE: [MessageHandler(filters.TEXT & ~filters.COMMAND, delete_promo)],
        },
        fallbacks=[],
        per_message=True
    )
    application.add_handler(promo_conv_handler)
    
    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–Ω–∞–ª–∞–º–∏ —Ä–∞—Å—Å—ã–ª–∫–∏
    channel_conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("chatbotV2", chatbotV2_start)
        ],
        states={
            AWAIT_CHANNEL_ACTION: [CallbackQueryHandler(handle_channel_action)],
            AWAIT_CHANNEL_ADD: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_channel_handler)],
            AWAIT_CHANNEL_DELETE: [MessageHandler(filters.TEXT & ~filters.COMMAND, remove_channel_handler)],
            AWAIT_CHANNEL_MESSAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, send_to_channels)],
        },
        fallbacks=[],
        per_message=True
    )
    application.add_handler(channel_conv_handler)
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è JobQueue
    job_queue = application.job_queue
    if job_queue:
        job_queue.run_repeating(auto_clicker_job, interval=60.0, first=10)
        logger.info("JobQueue —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
    else:
        logger.error("JobQueue –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞! –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ 'python-telegram-bot[job-queue]'")
    
    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
    application.run_polling()

if __name__ == "__main__":
    from keep_alive import keep_alive
    keep_alive()  # –∑–∞–ø—É—Å–∫–∞–µ–º –≤–µ–±-—Å–µ—Ä–≤–µ—Ä
    main()        # –∑–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
